


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Royal Dotted Globe</title>
<style>
  :root{
    --emerald: #00ff88;     /* stronger green aura */
    --base:    #0D1F10;     /* <-- your exact earth color */
    --dot:     #f5faff;     /* light dots */
    --badge:   rgba(36,42,38,0.9);
  }
  html, body { height:100%; margin:0; overflow:hidden; background:transparent; }

  /* brighter green background halo */
  body::before{
    content:""; position:fixed; inset:-40% -25% 0 -25%;
    background: radial-gradient(120% 70% at 50% -5%,
      rgba(0,255,136,0.50) 0%,
      rgba(0,255,136,0.28) 30%,
      rgba(0,255,136,0.12) 55%,
      rgba(0,0,0,0) 80%);
    z-index:-2; pointer-events:none;
  }

  canvas{ width:100%; height:100%; display:block; }

  /* flag pill with white dot */
  .tag{
    position:absolute; display:flex; align-items:center; gap:8px;
    padding:6px 10px; border-radius:12px;
    background: var(--badge);
    box-shadow: 0 2px 10px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.08);
    color:#eef2ff; font:500 12px/1 ui-sans-serif,system-ui,Segoe UI,Roboto;
    transform: translate(-50%, -50%); pointer-events:none; opacity:0;
  }
  .tag .dot{
    width:14px; height:14px; border-radius:9999px; background:#ffffff;
    box-shadow: 0 0 0 2px rgba(0,0,0,.25) inset;
  }
  .tag .flag{
    width:28px; height:18px; border-radius:4px; object-fit:cover;
    box-shadow: 0 0 0 1px rgba(255,255,255,.25);
  }
</style>
</head>
<body>
  <canvas id="globeCanvas"></canvas>

  <!-- Flag tags -->
  <div id="tag-us" class="tag"><span class="dot"></span><img class="flag" src="https://flagcdn.com/w40/us.png" alt="USA"></div>
  <div id="tag-uk" class="tag"><span class="dot"></span><img class="flag" src="https://flagcdn.com/w40/gb.png" alt="UK"></div>
  <div id="tag-in" class="tag"><span class="dot"></span><img class="flag" src="https://flagcdn.com/w40/in.png" alt="India"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const canvas = document.getElementById('globeCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(74, 1, 0.1, 1000);
    camera.position.z = 2.35;

    function resize(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    // subtle lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.25));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(3, 2, 4);
    scene.add(dir);

    // -------- dotted land shader (kept roomy gaps) --------
    const loader = new THREE.TextureLoader();
    const landMaskURL = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg';


    const uniforms = {
      uMask:      { value: null },
      uDotScale:  { value: 120.0 },      // fewer cells → bigger gaps
      uDotSize:   { value: 0.28 },       // dot radius in each cell
      uThreshold: { value: 0.20 },       // land cutoff
      uDotColor:  { value: new THREE.Color("#f5faff")  },
      uBaseColor: { value: new THREE.Color("#0D1F10") },
      uLightDir:  { value: new THREE.Vector3().copy(dir.position).normalize() }
    };

    const globeMat = new THREE.ShaderMaterial({
      uniforms,
      transparent: true,
      vertexShader: `
        varying vec3 vNormal; varying vec2 vUv;
        void main(){ vUv = uv; vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
    //   fragmentShader: `
    //     precision highp float;
    //     uniform sampler2D uMask;
    //     uniform float uDotScale, uDotSize, uThreshold;
    //     uniform vec3 uDotColor, uBaseColor, uLightDir;
    //     varying vec2 vUv; varying vec3 vNormal;
    //     float luma(vec3 c){ return dot(c, vec3(0.299,0.587,0.114)); }
    //     void main(){
    //       float NdotL = clamp(dot(normalize(vNormal), normalize(uLightDir)), 0.0, 1.0);
    //       vec3 base = uBaseColor * mix(0.65, 1.10, NdotL);

    //       float ocean = luma(texture2D(uMask, vUv).rgb);
    //       float land  = 1.0 - ocean;
    //       float landMask = smoothstep(uThreshold - 0.05, uThreshold + 0.05, land);

    //       vec2 uv = vUv * uDotScale;
    //       vec2 gv = fract(uv) - 0.5;
    //       float d = length(gv);

    //       float dotEdge = smoothstep(uDotSize, uDotSize - 0.12, d);
    //       float a = (1.0 - dotEdge) * landMask;

    //       vec3 color = mix(base, uDotColor, a);
    //       if((a+0.02)<0.02) discard;
    //       gl_FragColor = vec4(color, 1.0);
    //     }
    //   `



    fragmentShader: `
  precision highp float;
  uniform sampler2D uMask;
  uniform float uDotScale, uDotSize, uThreshold;
  uniform vec3 uDotColor, uBaseColor, uLightDir;
  varying vec2 vUv; varying vec3 vNormal;

  float luma(vec3 c){ return dot(c, vec3(0.299,0.587,0.114)); }

  void main(){
    // Lighting for the base
    float NdotL = clamp(dot(normalize(vNormal), normalize(uLightDir)), 0.0, 1.0);
    vec3 base = uBaseColor * mix(0.65, 1.10, NdotL);

    // Land mask
    float ocean = luma(texture2D(uMask, vUv).rgb);
    float land  = 1.0 - ocean;
    float landMask = smoothstep(uThreshold - 0.05, uThreshold + 0.05, land);

    // Dotted grid
    vec2 uv = vUv * uDotScale;
    vec2 gv = fract(uv) - 0.5;
    float d = length(gv);

    float dotEdge = smoothstep(uDotSize, uDotSize - 0.12, d);
    float a = (1.0 - dotEdge) * landMask;

    // 🎯 Draw only dots, no solid land fill
    if (a > 0.02) {
        gl_FragColor = vec4(uDotColor, 1.0);  // dots
        } else {
         gl_FragColor = vec4(base, 1.0);       // base (#0D1F10) everywhere else
    }
  }
`




    });
    loader.load(landMaskURL, t => { t.anisotropy = 4; uniforms.uMask.value = t; });

    const globe = new THREE.Mesh(new THREE.SphereGeometry(1, 168, 168), globeMat);
    scene.add(globe);

    // ---- stronger emerald rim ----
    const atmosphere = new THREE.ShaderMaterial({
      transparent: true, depthWrite: false, side: THREE.BackSide,
      uniforms: { uColor: { value: new THREE.Color(getCSS('--emerald')) }, uStrength:{ value:0.52 }},
      vertexShader: `varying vec3 vNormal;
        void main(){ vNormal=normalize(normalMatrix*normal);
          gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader: `precision highp float; varying vec3 vNormal;
        uniform vec3 uColor; uniform float uStrength;
        void main(){ float rim = pow(1.0 - abs(vNormal.z), 2.0);
          float a = smoothstep(0.18,0.96,rim) * uStrength;
          gl_FragColor = vec4(uColor, a); }`
    });
    const halo = new THREE.Mesh(new THREE.SphereGeometry(1.07, 96, 96), atmosphere);
    scene.add(halo);

    // ---------- tags anchored to EXACT city coords ----------
    // NYC, London, Mumbai
    const tags = [
      { id:'tag-us', lat: 40.7128, lon: -74.0060, offsetY: 60,offsetX: -60 },  // New York
      { id:'tag-uk', lat: 51.5074, lon:  -0.1278 },  // London
      { id:'tag-in', lat: 19.0760, lon:  72.8777 }   // Mumbai
    ];
    const els = Object.fromEntries(tags.map(t => [t.id, document.getElementById(t.id)]));
    const tmp = new THREE.Vector3();


    // Put this near the mapping helpers
const LON_OFFSET_DEG = 100;       // ← key fix: shift the seam +90° east

// Use three.js Spherical so we match SphereGeometry's convention exactly
function latLonToVec3(latDeg, lonDeg, r = 1.045){
  // phi = polar from +Y, theta = azimuth from +Z toward +X (three.js convention)
  const phi   = THREE.MathUtils.degToRad(90 - latDeg);
  const theta = THREE.MathUtils.degToRad(lonDeg + LON_OFFSET_DEG);
  return new THREE.Vector3().setFromSpherical(new THREE.Spherical(r, phi, theta));
}

    // function updateTags(){
    //   const w = canvas.clientWidth, h = canvas.clientHeight;
    //   tags.forEach(t=>{
    //     const el = els[t.id];
    //     const local = latLonToVec3(t.lat, t.lon, 1.045); // slightly above surface
    //     const world = globe.localToWorld(local.clone());

    //     // hide if on far side of globe
    //     const normal = world.clone().normalize();
    //     const toCam  = camera.position.clone().sub(world).normalize();
    //     if (normal.dot(toCam) <= 0){ el.style.opacity = 0; return; }

    //     tmp.copy(world).project(camera);
    //     el.style.left = `${(tmp.x * 0.5 + 0.5) * w}px`;
    //     el.style.top  = `${(-tmp.y * 0.5 + 0.5) * h}px`;
    //     el.style.opacity = 1;
    //   });
    // }


    function updateTags(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  tags.forEach(t=>{
    const el = els[t.id];
    const local = latLonToVec3(t.lat, t.lon, 1.045);
    const world = globe.localToWorld(local.clone());

    const normal = world.clone().normalize();
    const toCam  = camera.position.clone().sub(world).normalize();
    if (normal.dot(toCam) <= 0){ el.style.opacity = 0; return; }

    tmp.copy(world).project(camera);
    const sx = ( tmp.x * 0.5 + 0.5 ) * w + (t.offsetX || 0);
    const sy = (-tmp.y * 0.5 + 0.5 ) * h + (t.offsetY || 0);

    el.style.left = `${sx}px`;
    el.style.top  = `${sy}px`;
    el.style.opacity = 1;
  });
}


    // interaction
    let dragging = false, prev = { x:0, y:0 };
    const speed = 0.005;

    canvas.addEventListener('mousedown', e => { dragging = true; prev = { x:e.clientX, y:e.clientY }; });
    window.addEventListener('mouseup', () => (dragging = false));
    canvas.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - prev.x, dy = e.clientY - prev.y;
      globe.rotation.y += dx * speed; globe.rotation.x += dy * speed;
      halo.rotation.copy(globe.rotation);
      prev = { x:e.clientX, y:e.clientY };
      updateTags();
    });

    canvas.addEventListener('touchstart', e => {
      dragging = true; const t = e.touches[0]; prev = { x:t.clientX, y:t.clientY };
    }, { passive:true });
    canvas.addEventListener('touchend', () => (dragging=false), { passive:true });
    canvas.addEventListener('touchmove', e => {
      if (!dragging) return;
      const t = e.touches[0];
      const dx = t.clientX - prev.x, dy = t.clientY - prev.y;
      globe.rotation.y += dx * speed; globe.rotation.x += dy * speed;
      halo.rotation.copy(globe.rotation);
      prev = { x:t.clientX, y:t.clientY };
      updateTags();
    }, { passive:true });

    function animate(){
      requestAnimationFrame(animate);
      if (!dragging){
        globe.rotation.y += 0.005;
        // globe.rotation.y += 0.00055;
        halo.rotation.copy(globe.rotation);
      }
      resize();
      renderer.render(scene, camera);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      updateTags();
    }
    animate();

    function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  </script>
</body>
</html>
